package microsoft.servicebus.activizeprovider.service;import java.io.ByteArrayInputStream;import java.io.IOException;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.util.Calendar;import java.util.HashMap;/* import javax.jms.JMSException; */import javax.security.cert.X509Certificate;import org.apache.qpid.proton.messenger.Messenger;import org.apache.qpid.proton.messenger.jni.JNIMessengerFactory;import org.codehaus.jackson.JsonGenerationException; import org.codehaus.jackson.JsonParseException;import org.codehaus.jackson.map.JsonMappingException; import org.codehaus.jackson.map.ObjectMapper; import android.content.Context;import android.content.Intent;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.Signature;import android.content.pm.PackageManager.NameNotFoundException;import android.os.AsyncTask;import android.os.Binder;import android.os.IBinder;import android.util.Log;import android.widget.Toast;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAAuthenticationToken;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;public class ActivizeProviderService extends SAAgent {	public static final String TAG = "ActivizeProviderService";		public Boolean isAuthentication = false;	public Context mContext = null;	public static final int SERVICE_CONNECTION_RESULT_OK = 0;	public static final int ACTIVIZE_CHANNEL_ID = 104;		public WatchData last = new WatchData();	HashMap<Integer, ActivizeProviderConnection> mConnectionsMap = null;	private final IBinder mBinder = new LocalBinder();	//private int authCount = 1;	public class LocalBinder extends Binder {		public ActivizeProviderService getService() {			return ActivizeProviderService.this;		}	}	public ActivizeProviderService() {		super(TAG, ActivizeProviderConnection.class);	}	public class ActivizeProviderConnection extends SASocket {		private int mConnectionId;		public ActivizeProviderConnection() {			super(ActivizeProviderConnection.class.getName());		}		@Override		public void onError(int channelId, String errorString, int error) {			Log.e(TAG, "Connection is not alive ERROR: " + errorString + "  "					+ error);		}		@Override		public void onReceive(int channelId, byte[] data) {			Log.d(TAG, "onReceive");						final ActivizeProviderConnection uHandler = mConnectionsMap.get(Integer					.parseInt(String.valueOf(mConnectionId)));			if(uHandler == null){				Log.e(TAG,"Error, can not get ActivizeProviderConnection handler");				return;			}						String message = new String(data);						ObjectMapper mapper = new ObjectMapper();			WatchData received = null;			try {				received = mapper.readValue(message, WatchData.class);			} catch (JsonParseException e2) {				// TODO Auto-generated catch block				e2.printStackTrace();			} catch (JsonMappingException e2) {				// TODO Auto-generated catch block				e2.printStackTrace();			} catch (IOException e2) {				// TODO Auto-generated catch block				e2.printStackTrace();			}						Calendar curr = Calendar.getInstance();						// String currDate = curr.get(Calendar.MONTH) + "/" + curr.get(Calendar.DATE) + "/" + curr.get(Calendar.YEAR);						String currDate = "8/" + curr.get(Calendar.DATE) + "/" + curr.get(Calendar.YEAR);			String currTime = curr.get(Calendar.HOUR_OF_DAY) + ":" + curr.get(Calendar.MINUTE) + ":" + curr.get(Calendar.SECOND);						PedometerData newData = new PedometerData("DEVICE40", "EventHubs", currDate, currTime);			newData.setCalorie(received.getCalorie());			newData.setDistance(received.getDistance());			newData.setRunStep(received.getRunStep());			newData.setWalkStep(received.getWalkStep());			newData.setTotalStep(received.getTotalStep());			newData.setDeltaCalorie(received.getCalorie() - last.getCalorie());			newData.setDeltaDistance(received.getDistance() - last.getDistance());			newData.setDeltaRunStep(received.getRunStep() - last.getRunStep());			newData.setDeltaWalkStep(received.getWalkStep() - last.getWalkStep());			newData.setDeltaTotalStep(received.getTotalStep() - last.getTotalStep());							String serialized = "";			try {				serialized = new ObjectMapper().writeValueAsString(newData);			} catch (JsonGenerationException e1) {				// TODO Auto-generated catch block				e1.printStackTrace();			} catch (JsonMappingException e1) {				// TODO Auto-generated catch block				e1.printStackTrace();			} catch (IOException e1) {				// TODO Auto-generated catch block				e1.printStackTrace();			}							/* JNIMessengerFactory messengerFactory = new JNIMessengerFactory();			Messenger msgr = messengerFactory.createMessenger();						try {				msgr.start();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			} */			new AsyncSend(serialized).execute();						last = received;			final String sendBack = serialized.concat(currTime);						try {				uHandler.send(ACTIVIZE_CHANNEL_ID, sendBack.getBytes());			}			catch (IOException e) {				e.printStackTrace();						}		}		@Override		protected void onServiceConnectionLost(int errorCode) {			Log.e(TAG, "onServiceConectionLost  for peer = " + mConnectionId					+ "error code =" + errorCode);			if (mConnectionsMap != null) {				mConnectionsMap.remove(mConnectionId);			}		}	}    @Override    public void onCreate() {        super.onCreate();        Log.i(TAG, "onCreate of smart view Provider Service");                SA mAccessory = new SA();        try {        	mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {        	// Error Handling        } catch (Exception e1) {            Log.e(TAG, "Cannot initialize Accessory package.");            e1.printStackTrace();			/*			 * Your application can not use Accessory package of Samsung			 * Mobile SDK. You application should work smoothly without using			 * this SDK, or you may want to notify user and close your app			 * gracefully (release resources, stop Service threads, close UI			 * thread, etc.)			 */            stopSelf();        }            }	        @Override     protected void onServiceConnectionRequested(SAPeerAgent peerAgent) {    	/*    	* The authenticatePeerAgent(peerAgent) API may not be working properly     	* depending on the firmware version of accessory device.         * Recommend to upgrade accessory device firmware if possible.        */    	//    	if(authCount%2 == 1)//    		isAuthentication = false;//    	else//    		isAuthentication = true; //    	authCount++;    	    	isAuthentication = false;    	    	if(isAuthentication) {            Toast.makeText(getBaseContext(), "Authentication On!", Toast.LENGTH_SHORT).show();            Log.e(TAG, "Start authenticatePeerAgent");            authenticatePeerAgent(peerAgent);        }    	else {            Toast.makeText(getBaseContext(), "Authentication Off!", Toast.LENGTH_SHORT).show();            Log.e(TAG, "acceptServiceConnectionRequest");            acceptServiceConnectionRequest(peerAgent);        }    		    }         protected void onAuthenticationResponse(SAPeerAgent uPeerAgent,    		SAAuthenticationToken authToken, int error) {				if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_CERTIFICATE_X509) {			mContext = getApplicationContext();			byte[] myAppKey = getApplicationCertificate(mContext);					if (authToken.getKey() != null) {				boolean matched = true;				if(authToken.getKey().length != myAppKey.length){					matched = false;				}else{					for(int i=0; i<authToken.getKey().length; i++){						if(authToken.getKey()[i]!=myAppKey[i]){							matched = false;						}					}				}								if (matched) {					acceptServiceConnectionRequest(uPeerAgent);					Log.e(TAG, "Auth-certification matched");				} else					Log.e(TAG, "Auth-certification not matched");									}		} else if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_NONE) 			Log.e(TAG, "onAuthenticationResponse : CERT_TYPE(NONE)");			}		private static byte[] getApplicationCertificate(Context context) {		if(context == null) {			Log.e(TAG, "getApplicationCertificate ERROR, context input null");			return null;		}		Signature[] sigs;		byte[] certificat = null;		String packageName = context.getPackageName();		if (context != null) {			try {				PackageInfo pkgInfo = null;				pkgInfo = context.getPackageManager().getPackageInfo(						packageName, PackageManager.GET_SIGNATURES);				if (pkgInfo == null) {					Log.e(TAG, "PackageInfo was null!");					return null;				}				sigs = pkgInfo.signatures;				if (sigs == null) {					Log.e(TAG, "Signature obtained was null!");				} else {					CertificateFactory cf = CertificateFactory							.getInstance("X.509");					ByteArrayInputStream stream = new ByteArrayInputStream(							sigs[0].toByteArray());					X509Certificate cert;					cert = X509Certificate.getInstance(stream);					certificat = cert.getPublicKey().getEncoded();				}			} catch (NameNotFoundException e) {				// TODO Auto-generated catch block				e.printStackTrace();			} catch (CertificateException e) {				// TODO Auto-generated catch block				e.printStackTrace();			} catch (javax.security.cert.CertificateException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}		return certificat;	}    	@Override	protected void onFindPeerAgentResponse(SAPeerAgent arg0, int arg1) {		// TODO Auto-generated method stub		Log.d(TAG, "onFindPeerAgentResponse  arg1 =" + arg1);	}	@Override	protected void onServiceConnectionResponse(SASocket thisConnection,			int result) {		if (result == CONNECTION_SUCCESS) {						if (thisConnection != null) {				ActivizeProviderConnection myConnection = (ActivizeProviderConnection) thisConnection;				if (mConnectionsMap == null) {					mConnectionsMap = new HashMap<Integer, ActivizeProviderConnection>();				}				myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);				Log.d(TAG, "onServiceConnection connectionID = "						+ myConnection.mConnectionId);				mConnectionsMap.put(myConnection.mConnectionId, myConnection);				Log.e(TAG, "Connection Success");			} else {				Log.e(TAG, "SASocket object is null");			}		} else if (result == CONNECTION_ALREADY_EXIST) {			Log.e(TAG, "onServiceConnectionResponse, CONNECTION_ALREADY_EXIST");		} else {			Log.e(TAG, "onServiceConnectionResponse result error =" + result);		}	}	@Override	public IBinder onBind(Intent arg0) {		return mBinder;	}		public class AsyncSend extends AsyncTask<Object,Object,String> {		/* Messenger sendMessenger; */		String messageText;				AsyncSend(/* Messenger m, */ String messageText) {			/* sendMessenger = m; */			if(messageText.equals(""))				this.messageText = "Default message";			else				this.messageText = messageText;		}		@Override		protected void onPreExecute() {			Log.v("my-tag", "Starting a send");		}				@Override		protected String doInBackground(Object... params) {			return UsingSwig.send(messageText);		}				@Override		protected void onPostExecute(String result) {			if(!result.equals("")) {								Log.v("my-tag", "Send status is: "+result);				Log.v("my-tag", "Sent: "+messageText);			}			else {				Log.v("my-tag", "Something happened with a send.");			}					}			}}